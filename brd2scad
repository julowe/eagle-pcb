#!/usr/bin/perl

# brd2scad - convert eagle PCB designs into OpenSCAD 3D model scripts
#
# Copyright (C) 2017-2018 Michael Moon
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

use strict;

use XML::Simple;
use Data::Dumper;

if (@ARGV < 1) {
	print "Usage: brd2scad <file.brd>\n";
	exit 0;
}

my @brd_offset;
my $scalefactor = 1.0 / 25.4 / 15.5;

my @gerber_board_outline;

sub gerber2plane {
	my ($fn, $module_name) = @_;

	my $contour;
	my $index;
	my @paths;

	open(TC, "<", $fn) and do {
		my @apertures;
		my $ca_text;
		my ($px, $py);

		print "module $module_name() { translate(gerber_offset) render() {\n";

		while (<TC>) {
			chomp;
			/^%ADD(\d+)R,([\d\.]+)X([\d\.]+)\*%/ && do {
				# rectangular aperture
				$apertures[$1] = sprintf("square([%g,%g], center=true)", $2 * 25.4, $3 * 25.4);
			};
			/^\%ADD(\d+)C,([\d\.]+)\*\%/ && do {
				# circular aperture
				$apertures[$1] = sprintf("circle(d=%g, \$fn=16)", $2 * 25.4);
			};
			/^\%ADD(\d+)OC(\d+),([\d\.]+)\*\%/ && do {
				# circular aperture (with specific sides)
				$apertures[$1] = sprintf("rotate(180 / %d) circle(d=%g, \$fn=%d)", $2, $3 * 25.4, $2);
			};
			/^D(\d+)\*/ && do {
				print "\t}\n" if $ca_text;
				$ca_text = $apertures[$1];
				print "\tunion() {\n";
			};
			/^G36/ && do {
				$contour =  "\t\trender() polygon(points=[\n";
				$index = 0;
				@paths = ();
			};
			/^G37/ && do {
				$contour =~ s/,\n$//s;
				$contour .= "]";
				if ($#paths > 1) {
					$contour .= ",\n\tpaths=[\n";
					for (@paths) {
						$contour .= ",\n" if $_ != $paths[0];
						$contour .= "\t\t\t[".join(",",@{$_})."]";
					}
					$contour .= "]\n\t";
				}
				else {
					$contour .= "\n";
				}
				$contour .= "\t\t);\n";
				print $contour;
				undef $contour;
			};
			/^X(\d+)Y(\d+)D(\d+)\*/ && do {
				my ($x, $y, $op) = ($1 * $scalefactor, $2 * $scalefactor, $3);
				if ($contour) {
					if ($op == 2) {
						push @paths, [];
					}

					push @{$paths[$#paths]}, $index;
					$contour .= sprintf("\t\t\t[%g,%g],\n", $x, $y);
					$index++;
				}
				else {
					if ($op == 1) {
						printf "\t\trender() hull() { translate([%g,%g]) %s; translate([%g,%g]) %s; };\n", $px, $py, $ca_text, $x, $y, $ca_text;
					}
					elsif ($op == 3) {
						printf "\t\ttranslate([%g,%g]) %s;\n", $x, $y, $ca_text;
					}
				}
				$px = $x; $py = $y;
			};
		}
		if ($ca_text) {
			print "\t}\n";
		}
		else {
			print "\tcircle(d=ee); // EMPTY LAYER\n";
		}
		print "}} // end $module_name\n";
		close TC;
	};
}

my $fileprefix = $ARGV[0]; $fileprefix =~ s/\.brd$//;

my $xml = new XML::Simple;
my $data = $xml->XMLin($ARGV[0]);

if (! -e $fileprefix."_board_outline.gm1") {
	print $fileprefix."_board_outline.gm1 doesn't exist - please run CAM and generate gerbers first!\n";
	die $fileprefix."_board_outline.gm1 not found";
}

open(SCAD, ">", $fileprefix.".scad");

select SCAD;

printf "// Generated from %s\n", $ARGV[0];
printf "// Got EAGLE version %s\n\n", $data->{version};
printf "include <eagle-pcb/common.scad>;\n\nboard_thickness = 1.6;\n";

for (@{$data->{drawing}->{board}->{plain}->{wire}}) {
	if ($_->{layer} == 20) {
		if (@brd_offset == 0) {
			@brd_offset = ($_->{x1}, $_->{y1}, $_->{x1}, $_->{y1});
		}
		$brd_offset[0] = $_->{x1} if $_->{x1} < $brd_offset[0];
		$brd_offset[1] = $_->{y1} if $_->{y1} < $brd_offset[1];
		$brd_offset[2] = $_->{x1} if $_->{x1} > $brd_offset[2];
		$brd_offset[3] = $_->{y1} if $_->{y1} > $brd_offset[3];
		$brd_offset[0] = $_->{x2} if $_->{x2} < $brd_offset[0];
		$brd_offset[1] = $_->{y2} if $_->{y2} < $brd_offset[1];
		$brd_offset[2] = $_->{x2} if $_->{x2} > $brd_offset[2];
		$brd_offset[3] = $_->{y2} if $_->{y2} > $brd_offset[3];
	}
}

if (1) {
	my $board;
	my @aabb;
	open(TC, "<", $fileprefix."_board_outline.gm1") or die "Couldn't open ".$fileprefix."_board_outline.gm1: $!";
	do {
		my @apertures;
		my $ca_text;
		$board = "module 2dboard() { translate(gerber_offset) render() polygon(points=[\n";
		my $index = 0;
		my @paths = ([]);
		while (<TC>) {
			chomp; s/\r//g;
			/X(\d+)Y(\d+)D(\d+)/ && do {
				my ($x, $y, $op) = ($1 * $scalefactor, $2 * $scalefactor, $3);

# 				if ($op == 2) {
# 					push @paths, [];
# 				}

				if (@aabb == 0) {
					@aabb = ($x, $y, $x, $y);
				}
				else {
					$aabb[0] = $x if $x < $aabb[0];
					$aabb[1] = $y if $y < $aabb[1];
					$aabb[2] = $x if $x > $aabb[2];
					$aabb[3] = $y if $y > $aabb[3];
				}

				push @{$paths[$#paths]}, $index;
				$board .= sprintf("\t\t[%g,%g],\n", $x, $y);
				$index++;
			};
		}
		$board =~ s/,\n$//s;
		$board .= "]";
		if ($#paths > 1) {
			$board .= ",\n\tpaths=[\n";
			for (@paths) {
				$board .= ",\n" if $_ != $paths[0];
				$board .= "\t\t[".join(",",@{$_})."]";
			}
			$board .= "]\n\t";
		}
		else {
			$board .= "\n";
		}
		$board .= ");\n} // end 2dboard\n";
		close TC;
	};
	printf "gerber_offset = [%g, %g]; // \n", $brd_offset[0] - $aabb[0], $brd_offset[1] - $aabb[1];

	print "\n$board";
}

if (1) {
	open(TC, "<", $fileprefix."_drills.txt") and do {
		my @apertures;
		my $ca_text;
		print "module drills() { translate(gerber_offset) render() {\n";
		while (<TC>) {
			chomp; s/\r//g;
			/^T(\d+)C([\d\.]+)/ && do {
				$apertures[$1] = sprintf("circle(d=%g, \$fn=16)", $2 * 25.4);
			};
			/^T(\d+)$/ && do {
				print "\t}\n" if $ca_text;
				$ca_text = $apertures[$1];
				print "\tunion() {\n";
			};
			/^X([\d\.]+)Y([\d\.]+)/ && do {
				my ($x, $y) = ($1 * $scalefactor, $2 * $scalefactor);
				printf "\t\ttranslate([%g,%g]) %s;\n", $x, $y, $ca_text;
			};
		}
		print "\t}\n}} // END DRILLS\n\n";
	};
}

gerber2plane($fileprefix."_top_copper.gtl", "gerber_tcopper");
gerber2plane($fileprefix."_top_soldermask.gts", "gerber_tstop");
gerber2plane($fileprefix."_top_silk.gto", "gerber_tsilk");

gerber2plane($fileprefix."_bottom_copper.gbl", "gerber_bcopper");
gerber2plane($fileprefix."_bottom_soldermask.gbs", "gerber_bstop");
gerber2plane($fileprefix."_bottom_silk.gbo", "gerber_bsilk");

print "\n";

print "color(light) render(convexity=5) linear_extrude(0.035) difference() { gerber_tcopper(); drills(); }\n";
print "color(soldermask) render(convexity=5) linear_extrude(0.035 + ee) difference() { 2dboard(); gerber_tstop(); }\n";
print "color(white) render(convexity=5) linear_extrude(0.035 + ee + ee) intersection() { difference() { gerber_tsilk(); offset(0.1) gerber_tstop(); offset(0.1) drills(); } 2dboard(); }\n\n";

print "color(fr4) render(convexity=5) translate([0, 0, -board_thickness]) linear_extrude(board_thickness) difference() { 2dboard(); drills(); }\n\n";

print "color(light) render(convexity=5) bottom(board_thickness) linear_extrude(0.035) difference() { gerber_bcopper(); drills(); }\n";
print "color(soldermask) render(convexity=5) bottom(board_thickness) linear_extrude(0.035 + ee) difference() { 2dboard(); gerber_bstop(); }\n";
print "color(white) render(convexity=5) bottom(board_thickness) linear_extrude(0.035 + ee + ee) intersection() { difference() { gerber_bsilk(); offset(0.1) gerber_bstop(); offset(0.1) drills(); } 2dboard(); }\n";

print "\n";

# TODO: grab library footprints. Use them to attempt generation of unknown packages

if (1) {
	my %loaded_libraries;
	for my $element (keys %{$data->{drawing}->{board}->{elements}->{element}}) {
		my %part = %{$data->{drawing}->{board}->{elements}->{element}->{$element}};
		if (defined $part{x}) {
			if (! defined $loaded_libraries{$part{library}}) {
				printf "\tuse <eagle-pcb/%s.scad>;\n", $part{library};
				$loaded_libraries{$part{library}} = 1;
			}
		}
	}

	print "translate([0, 0, ee2]) group() { // COMPONENTS\n";
	for my $element (keys %{$data->{drawing}->{board}->{elements}->{element}}) {
		my %part = %{$data->{drawing}->{board}->{elements}->{element}->{$element}};
		if (defined $part{x}) {
			if (! defined $loaded_libraries{$part{library}}) {
				printf "\tuse <eagle-pcb/%s.scad>;\n", $part{library};
				$loaded_libraries{$part{library}} = 1;
			}
			print "\t";
			printf "translate([%g,%g,0]) ", $part{x}, $part{y};
			printf "bottom(board_thickness) mirror([1, 0, 0]) " if $part{rot} =~ /^M/;
			printf "rotate([0, 0, %g]) ", $1 if $part{rot} =~ /R(\d+)/;

			my $pn = $part{library}."_".$part{package};
			$pn =~ s![^a-zA-Z0-9_]!_!g;
			print "$pn(name=\"".$element."\", value=\"".$part{value}."\"); // $element" . (($part{rot} =~ /^M/)?" (bottom)":""). "\n";
		}
	}
	print "} // END COMPONENTS\n";
}

print "\n\n";

select STDOUT;
